简答题
1.
执行结果为在控制台打印10
题目代码相当于
var a = [],i=0;
for(; i < 10; i++){
    a[i] = function(){
        console.log(i)
    }
}
a[6]()
由于var定义变量的特性，i其实相当于全局变量，在for循环的执行过程中，每一轮for循环执行完i都会加1，for循环执行完成后i的值为10，此时for循环中为a[i]赋值操作中的i也始终是全局变量中的i，也就是现在为10的i。

2.会报错。因为虽然在全局中定义了变量tmp，但是在if的执行语句中，包含{}，也就是说形成了一个块级作用域。在这个作用域中定义了let tmp，let与var的不同之处有一点就是let不会提升变量。在if的执行语句中，先使用了变量tmp再定义tmp，这里就会报错。

3.
var arr = [12, 34, 32, 89, 4]
Math.min(...arr)

4.
var
其作用域为该语句所在的函数内，且存在变量提升现象
let
有块级作用域，不存在变量提升
const
有块级作用域，不存在变量提升，基本类型用const定义后不能再改变基本类型的值，obj类型在定义后不能再改变指针指向

5.
题目中代码
var obj = {
    a : 20,
    fn(){
        setTimeout(()=>{
            console.log(this.a)
        })
    }
}
obj.fn()
输出结果为20
这里需要注意到的点是setTimeout中用箭头函数定义的，箭头函数的特点之一是它的this指向是在定义的时候完成的，它的指向是定义时所在的作用域。也就是说在本例中箭头函数是在fn中定义的，所以this的指向是fn的指向，fn定义在obj中，obj是没有独立作用域的，但是obj.fn()调用的时候fn是被obj调用，所以fn的this是指向obj的

6.
(1)Symbol最大的特性是每次被调用的时候都会产生独一无二的值，这个值可以作为属性名const obj = {}
(2)也可以通过Symbol的特性来模拟对象的私有成员
const name = Symbol()
const person = {
    [name] : 'zce',
    say(){
        console.log(this[name])
    }
}
person[Symbol()]//不能访问，因为Symbol成员不能产生完全一样的值
(3)Symbol方法中还定义了很多内置的Symbol常量来作为内部方法的标识，可以让一些自定义对象实现js当中内置的一些接口
const obj1 = {
    [Symbol.toStringTag]:'XObject'
}
console.log(obj1.toString())//[object XObject]

7.
对于引用数据类型(对象等是引用数据类型)名存在栈内存中，值存在于堆内存中，但是栈内存会提供一个引用的地址指向堆内存中的值
浅拷贝仅仅是指向被拷贝的对象的内存地址，也就是复制的是对象在栈内存中的引用地址，如果原地址中对象被改变了，那么浅拷贝出来的对象也会相应改变
深拷贝在堆内存中开辟了一块内存地址用于存放复制的对象，在栈内存中重新存放新开辟这块对象的地址
深拷贝和浅拷贝最根本的区别在于是否是真正获取了一个对象的复制实体，而不是引用

8.
TypeScript是基于JavaScript基础之上的编程语言，很多时候我们都在说是JavaScript的超集。TypeScript可以编译为JavaScript，那么任何支持JavaScript的运行环境都支持TypeScript。
JavaScript 和 TypeScript 的主要差异
TypeScript 可以使用 JavaScript 中的所有代码和编码概念，TypeScript 是为了使 JavaScript 的开发变得更加容易而创建的。例如，TypeScript 使用类型和接口等概念来描述正在使用的数据，这使开发人员能够快速检测错误并调试应用程序
·TypeScript 从核心语言方面和类概念的模塑方面对 JavaScript 对象模型进行扩展。
·JavaScript 代码可以在无需任何修改的情况下与 TypeScript 一同工作，同时可以使用编译器将 TypeScript 代码转换为 JavaScript。
·TypeScript 通过类型注解提供编译时的静态类型检查。
·TypeScript 中的数据要求带有明确的类型，JavaScript不要求。
·TypeScript 为函数提供了缺省参数值。
·TypeScript 引入了 JavaScript 中没有的“类”概念。
·TypeScript 中引入了模块的概念，可以把声明、数据、函数和类封装在模块中。

9.
TypeScript 的优势
(1)静态输入
静态类型化是一种功能，可以在开发人员编写脚本时检测错误。查找并修复错误是当今开发团队的迫切需求。有了这项功能，就会允许开发人员编写更健壮的代码并对其进行维护，以便使得代码质量更好、更清晰。
(2)大型的开发项目
有时为了改进开发项目，需要对代码库进行小的增量更改。这些小小的变化可能会产生严重的、意想不到的后果，因此有必要撤销这些变化。使用TypeScript工具来进行重构更变的容易、快捷。
(3)更好的协作
当发开大型项目时，会有许多开发人员，此时乱码和错误的机也会增加。类型安全是一种在编码期间检测错误的功能，而不是在编译项目时检测错误。这为开发团队创建了一个更高效的编码和调试过程。
(4)更强的生产力
干净的 ECMAScript 6 代码，自动完成和动态输入等因素有助于提高开发人员的工作效率。这些功能也有助于编译器创建优化的代码。
但是相对JavaScript而言，TypeScript需要更多的学习成本，在开发初期因为要配置TypeScript的相关内容，也多了一些开销，虽然随着项目的开发我们会发现项目初期多出来的开销是值得的。相对TypeScript，JavaScript相关的资源/开发项目会更多。而且JavaScript不需要被编译就能在浏览器等环境中执行，而Typescript需要编译过程，也是多了一些开销。

10.
引用计数:跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则该值的引用次数就是1；如果同一个值又被赋给另一个变量，则该值的引用次数加1；如果包含对该值引用的变量又取得了另外一个值，则该值的引用次数减1。当该值的引用次数变为0时，则可以回收其占用的内存空间。当垃圾回收器下一次运行时，就会释放那些引用次数为0的值所占用的内存。
优点：
·发现垃圾时立即回收
·最大限度减少程序暂停(应用程序执行必然对内存有消耗，而我们执行平台的内存是有上限的，内存肯定有占满的时候，由于引用计数算法时刻监控着引用数值为0的情况，即使内存即将被占满，由于有引用计数时刻监测着引用为0的变量，进行垃圾回收，保证了当前内存不会有占满的时候)
缺点：
·无法回收循环引用的对象
·时间开销大(当前引用计数需要维护一个数值的变化，就需要时刻监控当前对象的引用数值是否发生变化，数值修改本身就需要消耗时间，如果内存中很多对象都需要变化时间就会显得更大一些)

11.
标记整理算法：通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收。

12.
V8内存一分为二(新生代，老生代)，小空间用于存储新生代对象，新生代对象指存活时间较短代对象(经过一轮GC就会被回收的对象)。新生代内存区同样会被一分为二(等大小 `From & To`)，活动的对象存储在`From`空间内，当From空间应用到一定大小的时候就会`触发GC操作使用标记整理并整理活动对象的地址，使其连续`然后将活动对象拷贝至To，然后From空间进行内存释放。在从`From`到`To`拷贝的过程中有可能出现变量晋升的情况，变量晋升就是新生代的对象移动到老生代。当1.当一轮GC执行完毕之后还存活的新生代则需要晋升；2.当To空间的使用率超过25%的时候，同样需要将此次的活动对象均移动到老生代中。当完成一次GC操作之后，From 和 To需要进行置换。

13.
增量标记算法并不会等GC执行完, 才将控制权交回程序, 而是一步一步执行, 跑一点, 再跑一点, 逐步完成垃圾回收, 在程序运行中穿插进行. 极大地降低了GC的最大暂停时间.
之前说的各种垃圾回收, 都需要暂停程序, 执行GC, 这就导致在GC执行期间, 程序得不到执行. 因此出现了增量式垃圾回收, 它并不会等GC执行完, 才将控制权交回程序, 而是一步一步执行, 跑一点, 再跑一点, 逐步完成垃圾回收, 在程序运行中穿插进行. 极大地降低了GC的最大暂停时间.